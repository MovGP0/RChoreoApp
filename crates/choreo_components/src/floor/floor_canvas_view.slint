import { MaterialPalette, MaterialTypography, Vertical } from "@material";
import { FloorHeaderOverlay } from "floor_header_overlay.slint";
import { AxisLabel, FloorCurve, FloorInfo, FloorPosition, LineSegment } from "floor_info.slint";
import { FloorMetricsInfo } from "floor_metrics_info.slint";
import { FloorLegendEntries, FloorLegendPanel, LegendEntry } from "floor_legend_panel.slint";
import { Translations } from "../../ui/translations.slint";
import { ZoomPanInfo } from "zoom_pan_info.slint";
export { AxisLabel, FloorCurve, FloorPosition, LineSegment } from "floor_info.slint";
export { LegendEntry } from "floor_legend_panel.slint";

export component FloorCanvasView inherits Rectangle {
    property <int> floor_front: FloorInfo.floor_front;
    property <int> floor_back: FloorInfo.floor_back;
    property <int> floor_left: FloorInfo.floor_left;
    property <int> floor_right: FloorInfo.floor_right;
    property <bool> show_grid_lines: FloorInfo.floor_show_grid_lines;
    property <color> surface_color: MaterialPalette.surface;
    property <color> floor_color: FloorInfo.floor_color;
    property <color> grid_color: MaterialPalette.secondary;
    property <color> floor_border_color: MaterialPalette.primary;
    property <color> title_color: MaterialPalette.on_surface;
    property <length> header_padding: 16px;
    property <length> header_spacing: 4px;
    property <length> header_floor_spacing: 20px;
    property <length> grid_padding: 46px;
    property <length> grid_line_thickness: 1px;
    property <length> border_thickness: 2px;
    property <length> center_line_thickness: 2px;
    property <length> center_dot_size: 8px;
    property <float> dancer_size: FloorInfo.floor_dancer_size;
    property <length> dancer_border_thickness: 2px;
    property <length> dancer_selection_thickness: 3px;
    property <length> dancer_selection_padding: 4px;
    property <color> dancer_selection_color: MaterialPalette.secondary;
    property <[FloorPosition]> positions: FloorInfo.floor_positions;
    property <[FloorCurve]> curves: FloorInfo.floor_curves;
    property <[LineSegment]> dashed_curve_segments: FloorInfo.floor_dashed_curve_segments;
    property <[LineSegment]> selection_segments: FloorInfo.floor_selection_segments;
    property <[AxisLabel]> axis_labels_x: FloorInfo.floor_axis_labels_x;
    property <[AxisLabel]> axis_labels_y: FloorInfo.floor_axis_labels_y;
    property <length> axis_label_offset: 12px;
    property <length> axis_label_floor_padding: 3px;
    property <length> axis_label_size: MaterialTypography.label_large.font_size;
    property <int> axis_label_weight: MaterialTypography.label_large.font_weight;
    property <bool> show_axis_labels: FloorInfo.floor_show_axis_labels;
    property <image> svg_overlay: FloorInfo.floor_svg_overlay;
    property <bool> has_svg_overlay: FloorInfo.floor_has_svg_overlay;
    property <bool> show_placement_overlay: FloorInfo.floor_show_placement_overlay;
    property <int> remaining_positions: FloorInfo.floor_remaining_positions;
    property <length> placement_padding: 12px;
    property <length> placement_spacing: 4px;
    property <length> placement_corner_radius: 8px;
    property <length> placement_title_size: MaterialTypography.title_medium.font_size;
    property <int> placement_title_weight: MaterialTypography.title_medium.font_weight;
    property <length> placement_body_size: MaterialTypography.body_medium.font_size;
    property <int> placement_body_weight: MaterialTypography.body_medium.font_weight;
    property <length> header_title_size: MaterialTypography.title_large.font_size;
    property <int> header_title_weight: MaterialTypography.title_large.font_weight;
    property <length> header_subtitle_size: MaterialTypography.body_medium.font_size;
    property <int> header_subtitle_weight: MaterialTypography.body_medium.font_weight;
    property <color> placement_title_color: MaterialPalette.on_surface;
    property <color> placement_body_color: MaterialPalette.on_surface_variant;
    property <color> placement_background_color: MaterialPalette.surface_variant;
    out property <float> floor_bounds_left: content.floor_x / 1px;
    out property <float> floor_bounds_top: content.floor_y / 1px;
    out property <float> floor_bounds_right: (content.floor_x + content.floor_width) / 1px;
    out property <float> floor_bounds_bottom: (content.floor_y + content.floor_height) / 1px;
    out property <float> canvas_width: root.width / 1px;
    out property <float> canvas_height: root.height / 1px;
    out property <float> header_bottom: (content.floor_y - content.header_floor_spacing_px * 1px) / 1px;
    out property <float> floor_width: content.floor_width / 1px;
    out property <float> floor_height: content.floor_height / 1px;
    out property <float> legend_panel_measured_width: legend_panel.panel_measured_width;
    out property <float> legend_panel_measured_height: legend_panel.panel_measured_height;
    out property <float> legend_content_padding_left: legend_panel.content_padding_left;
    out property <float> legend_content_padding_top: legend_panel.content_padding_top;
    out property <float> legend_content_padding_right: legend_panel.content_padding_right;
    out property <float> legend_content_padding_bottom: legend_panel.content_padding_bottom;
    out property <float> legend_first_square_offset_x: legend_panel.first_square_offset_x;
    out property <float> legend_first_square_offset_y: legend_panel.first_square_offset_y;
    out property <float> legend_first_row_offset_x: legend_panel.first_row_offset_x;
    out property <float> legend_first_row_offset_y: legend_panel.first_row_offset_y;
    out property <float> legend_last_row_bottom_gap: legend_panel.last_row_bottom_gap;
    out property <float> side_label_left_gap:
        (floor_rect.x - (side_label_left_probe.x + side_label_left_probe.width)) / 1px;
    out property <float> side_label_right_gap:
        (side_label_right_probe.x - (floor_rect.x + floor_rect.width)) / 1px;
    out property <float> top_label_vertical_gap:
        (floor_rect.y - (top_label_probe.y + top_label_probe.height)) / 1px;
    out property <float> bottom_label_vertical_gap:
        (bottom_label_probe.y - (floor_rect.y + floor_rect.height)) / 1px;
    out property <float> legend_text_probe_font_size: legend_panel.text_probe_font_size;
    out property <float> legend_text_probe_height: legend_panel.text_probe_height;

    property <float> floor_width_meters: (floor_left + floor_right) * 1.0;
    property <float> floor_height_meters: (floor_front + floor_back) * 1.0;

    callback redraw();
    callback pointer_pressed(x: float, y: float, is_primary: bool, is_in_contact: bool);
    callback pointer_moved(x: float, y: float, is_primary: bool, is_in_contact: bool);
    callback pointer_released(x: float, y: float, is_primary: bool, is_in_contact: bool);
    callback pointer_wheel_changed(
        delta_x: float,
        delta_y: float,
        x: float,
        y: float,
        control_modifier: bool
    );

    function sync_layout_metrics() {
        FloorMetricsInfo.floor_bounds_left = root.floor_bounds_left;
        FloorMetricsInfo.floor_bounds_top = root.floor_bounds_top;
        FloorMetricsInfo.floor_bounds_right = root.floor_bounds_right;
        FloorMetricsInfo.floor_bounds_bottom = root.floor_bounds_bottom;
        FloorMetricsInfo.floor_canvas_width = root.canvas_width;
        FloorMetricsInfo.floor_canvas_height = root.canvas_height;
        FloorMetricsInfo.floor_header_bottom = root.header_bottom;
        FloorMetricsInfo.floor_width = root.floor_width;
        FloorMetricsInfo.floor_height = root.floor_height;
        FloorMetricsInfo.floor_legend_panel_width = root.legend_panel_measured_width;
        FloorMetricsInfo.floor_legend_panel_height = root.legend_panel_measured_height;
        FloorMetricsInfo.floor_legend_content_padding_left = root.legend_content_padding_left;
        FloorMetricsInfo.floor_legend_content_padding_top = root.legend_content_padding_top;
        FloorMetricsInfo.floor_legend_content_padding_right = root.legend_content_padding_right;
        FloorMetricsInfo.floor_legend_content_padding_bottom = root.legend_content_padding_bottom;
        FloorMetricsInfo.floor_legend_first_square_offset_x = root.legend_first_square_offset_x;
        FloorMetricsInfo.floor_legend_first_square_offset_y = root.legend_first_square_offset_y;
        FloorMetricsInfo.floor_legend_first_row_offset_x = root.legend_first_row_offset_x;
        FloorMetricsInfo.floor_legend_first_row_offset_y = root.legend_first_row_offset_y;
        FloorMetricsInfo.floor_legend_last_row_bottom_gap = root.legend_last_row_bottom_gap;
        FloorMetricsInfo.floor_side_label_left_gap = root.side_label_left_gap;
        FloorMetricsInfo.floor_side_label_right_gap = root.side_label_right_gap;
        FloorMetricsInfo.floor_top_label_vertical_gap = root.top_label_vertical_gap;
        FloorMetricsInfo.floor_bottom_label_vertical_gap = root.bottom_label_vertical_gap;
        FloorMetricsInfo.floor_legend_text_probe_font_size = root.legend_text_probe_font_size;
        FloorMetricsInfo.floor_legend_text_probe_height = root.legend_text_probe_height;
    }

    init => { root.sync_layout_metrics(); }

    changed floor_bounds_left => { root.sync_layout_metrics(); root.redraw(); }
    changed floor_bounds_top => { root.sync_layout_metrics(); root.redraw(); }
    changed floor_bounds_right => { root.sync_layout_metrics(); root.redraw(); }
    changed floor_bounds_bottom => { root.sync_layout_metrics(); root.redraw(); }
    changed canvas_width => { root.sync_layout_metrics(); root.redraw(); }
    changed canvas_height => { root.sync_layout_metrics(); root.redraw(); }
    changed header_bottom => { root.sync_layout_metrics(); }
    changed floor_width => { root.sync_layout_metrics(); }
    changed floor_height => { root.sync_layout_metrics(); }
    changed legend_panel_measured_width => { root.sync_layout_metrics(); }
    changed legend_panel_measured_height => { root.sync_layout_metrics(); }
    changed legend_content_padding_left => { root.sync_layout_metrics(); }
    changed legend_content_padding_top => { root.sync_layout_metrics(); }
    changed legend_content_padding_right => { root.sync_layout_metrics(); }
    changed legend_content_padding_bottom => { root.sync_layout_metrics(); }
    changed legend_first_square_offset_x => { root.sync_layout_metrics(); }
    changed legend_first_square_offset_y => { root.sync_layout_metrics(); }
    changed legend_first_row_offset_x => { root.sync_layout_metrics(); }
    changed legend_first_row_offset_y => { root.sync_layout_metrics(); }
    changed legend_last_row_bottom_gap => { root.sync_layout_metrics(); }
    changed side_label_left_gap => { root.sync_layout_metrics(); }
    changed side_label_right_gap => { root.sync_layout_metrics(); }
    changed top_label_vertical_gap => { root.sync_layout_metrics(); }
    changed bottom_label_vertical_gap => { root.sync_layout_metrics(); }
    changed legend_text_probe_font_size => { root.sync_layout_metrics(); }
    changed legend_text_probe_height => { root.sync_layout_metrics(); }
    changed width => { root.sync_layout_metrics(); root.redraw(); }
    changed height => { root.sync_layout_metrics(); root.redraw(); }

    background: surface_color;

    Vertical {
        spacing: 0px;

        content := Rectangle {
            vertical-stretch: 1;
            background: root.surface_color;
            changed floor_x => { root.redraw(); }
            changed floor_y => { root.redraw(); }
            changed floor_width => { root.redraw(); }
            changed floor_height => { root.redraw(); }

            property <float> content_width_px: self.width / 1px;
            property <float> content_height_px: self.height / 1px;
            property <float> padding_px: root.grid_padding / 1px;
            property <float> zoom_factor: ZoomPanInfo.zoom_factor;
            property <float> pan_x: ZoomPanInfo.pan_x;
            property <float> pan_y: ZoomPanInfo.pan_y;
            property <float> user_scale: ZoomPanInfo.user_scale(zoom_factor);
            property <float> user_translate_x_px: pan_x;
            property <float> user_translate_y_px: pan_y;
            property <float> base_header_floor_spacing_px:
                root.header_floor_spacing / 1px
                + (root.show_axis_labels ? root.axis_label_size / 1px : 0.0);
            property <float> header_floor_spacing_px: base_header_floor_spacing_px * text_scale;
            property <length> legend_reserved_width:
                FloorLegendEntries.show_legend && FloorLegendEntries.legend_entries.length > 0
                ? FloorLegendEntries.legend_panel_width + FloorLegendEntries.legend_margin
                : 0px;
            property <float> layout_width_px: content_width_px > legend_reserved_width / 1px
                ? content_width_px - legend_reserved_width / 1px
                : 0.0;
            property <float> available_width_px: layout_width_px > 2.0 * padding_px
                ? layout_width_px - 2.0 * padding_px
                : 0.0;
            property <float> available_height_px: content_height_px > header_overlay.base_header_height_px + base_header_floor_spacing_px + 2.0 * padding_px
                ? content_height_px - header_overlay.base_header_height_px - base_header_floor_spacing_px - 2.0 * padding_px
                : 0.0;
            property <float> scale_x: root.floor_width_meters > 0.0
                ? available_width_px / root.floor_width_meters
                : 1.0;
            property <float> scale_y: root.floor_height_meters > 0.0
                ? available_height_px / root.floor_height_meters
                : 1.0;
            property <float> base_scale: ZoomPanInfo.base_scale(scale_x, scale_y);
            property <float> scale: ZoomPanInfo.scale(base_scale, user_scale);
            property <float> text_scale: ZoomPanInfo.text_scale(scale);
            property <float> base_text_scale: ZoomPanInfo.base_text_scale(base_scale);
            property <length> base_floor_width: root.floor_width_meters > 0.0
                ? root.floor_width_meters * base_scale * 1px
                : 0px;
            property <length> base_floor_height: root.floor_height_meters > 0.0
                ? root.floor_height_meters * base_scale * 1px
                : 0px;
            property <length> base_floor_x: (layout_width_px * 1px - base_floor_width) / 2;
            property <length> base_floor_y: (header_overlay.base_header_height_px + base_header_floor_spacing_px) * 1px
                + (parent.height - (header_overlay.base_header_height_px + base_header_floor_spacing_px) * 1px - base_floor_height) / 2;
            property <length> floor_width: base_floor_width * user_scale;
            property <length> floor_height: base_floor_height * user_scale;
            property <length> floor_x: ZoomPanInfo.apply_zoom_and_pan(
                base_floor_x,
                user_scale,
                user_translate_x_px
            );
            property <length> floor_y: ZoomPanInfo.apply_zoom_and_pan(
                base_floor_y,
                user_scale,
                user_translate_y_px
            );
            property <length> center_x: floor_x + floor_width / 2;
            property <length> center_y: floor_y + floor_height / 2;
            property <length> base_origin_x: base_floor_x + root.floor_left * base_scale * 1px;
            property <length> base_origin_y: base_floor_y + root.floor_front * base_scale * 1px;
            property <length> origin_x: ZoomPanInfo.apply_zoom_and_pan(
                base_origin_x,
                user_scale,
                user_translate_x_px
            );
            property <length> origin_y: ZoomPanInfo.apply_zoom_and_pan(
                base_origin_y,
                user_scale,
                user_translate_y_px
            );
            property <float> floor_width_px: floor_width / 1px;
            property <float> floor_height_px: floor_height / 1px;
            floor_rect := Rectangle {
                width: content.floor_width;
                height: content.floor_height;
                x: content.floor_x;
                y: content.floor_y;
                z: 0;
                background: root.floor_color;
                border-width: root.border_thickness;
                border-color: root.floor_border_color;
            }

            grid := Rectangle {
                x: floor_rect.x;
                y: floor_rect.y;
                width: floor_rect.width;
                height: floor_rect.height;
                z: 1;
                background: transparent;
                clip: true;
                visible: root.show_grid_lines;

                for i in root.floor_left : Rectangle {
                    width: root.grid_line_thickness;
                    height: parent.height;
                    background: root.grid_color;
                    opacity: 0.5;
                    x: content.origin_x - floor_rect.x - self.width / 2 - (i + 1) * content.scale * 1px;
                    y: 0px;
                }

                for i in root.floor_right : Rectangle {
                    width: root.grid_line_thickness;
                    height: parent.height;
                    background: root.grid_color;
                    opacity: 0.5;
                    x: content.origin_x - floor_rect.x - self.width / 2 + (i + 1) * content.scale * 1px;
                    y: 0px;
                }

                for i in root.floor_front : Rectangle {
                    width: parent.width;
                    height: root.grid_line_thickness;
                    background: root.grid_color;
                    opacity: 0.5;
                    x: 0px;
                    y: content.origin_y - floor_rect.y - self.height / 2 - (i + 1) * content.scale * 1px;
                }

                for i in root.floor_back : Rectangle {
                    width: parent.width;
                    height: root.grid_line_thickness;
                    background: root.grid_color;
                    opacity: 0.5;
                    x: 0px;
                    y: content.origin_y - floor_rect.y - self.height / 2 + (i + 1) * content.scale * 1px;
                }
            }

            center_layer := Rectangle {
                x: floor_rect.x;
                y: floor_rect.y;
                width: floor_rect.width;
                height: floor_rect.height;
                z: 1;
                background: transparent;

                Rectangle {
                    width: root.center_line_thickness;
                    height: parent.height;
                    background: root.floor_border_color;
                    x: content.origin_x - floor_rect.x - self.width / 2;
                    y: 0px;
                }

                Rectangle {
                    width: parent.width;
                    height: root.center_line_thickness;
                    background: root.floor_border_color;
                    x: 0px;
                    y: content.origin_y - floor_rect.y - self.height / 2;
                }

                Rectangle {
                    width: root.center_dot_size;
                    height: root.center_dot_size;
                    border-radius: self.width / 2;
                    background: root.floor_border_color;
                    x: content.origin_x - floor_rect.x - self.width / 2;
                    y: content.origin_y - floor_rect.y - self.height / 2;
                }
            }

            svg_overlay_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                z: 2;
                background: transparent;
                visible: root.has_svg_overlay;

                Image {
                    source: root.svg_overlay;
                    width: content.layout_width_px * 1px * content.user_scale;
                    height: content.content_height_px * 1px * content.user_scale;
                    x: content.origin_x - self.width / 2;
                    y: content.origin_y - self.height / 2;
                    image-fit: contain;
                }
            }

            axis_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                z: 6;
                background: transparent;
                visible: root.show_axis_labels;

                for label in root.axis_labels_x: Text {
                    text: label.text;
                    color: MaterialPalette.on_surface_variant;
                    font-size: ZoomPanInfo.corrected_text_size(
                        root.axis_label_size,
                        content.text_scale
                    );
                    font-weight: root.axis_label_weight;
                    horizontal-alignment: center;
                    x: content.origin_x + label.value * content.scale * 1px - self.width / 2;
                    y: floor_rect.y
                        - root.axis_label_offset * content.text_scale
                        - root.axis_label_floor_padding * content.text_scale
                        - self.height;
                }

                for label in root.axis_labels_x: Text {
                    text: label.text;
                    color: MaterialPalette.on_surface_variant;
                    font-size: ZoomPanInfo.corrected_text_size(
                        root.axis_label_size,
                        content.text_scale
                    );
                    font-weight: root.axis_label_weight;
                    horizontal-alignment: center;
                    x: content.origin_x + label.value * content.scale * 1px - self.width / 2;
                    y: floor_rect.y
                        + floor_rect.height
                        + root.axis_label_offset * content.text_scale
                        + root.axis_label_floor_padding * content.text_scale;
                }

                for label in root.axis_labels_y: Text {
                    text: label.text;
                    color: MaterialPalette.on_surface_variant;
                    font-size: ZoomPanInfo.corrected_text_size(
                        root.axis_label_size,
                        content.text_scale
                    );
                    font-weight: root.axis_label_weight;
                    horizontal-alignment: right;
                    x: floor_rect.x - root.axis_label_offset * content.text_scale - self.width;
                    y: content.origin_y - label.value * content.scale * 1px - self.height / 2;
                }

                for label in root.axis_labels_y: Text {
                    text: label.text;
                    color: MaterialPalette.on_surface_variant;
                    font-size: ZoomPanInfo.corrected_text_size(
                        root.axis_label_size,
                        content.text_scale
                    );
                    font-weight: root.axis_label_weight;
                    horizontal-alignment: left;
                    x: floor_rect.x + floor_rect.width + root.axis_label_offset * content.text_scale;
                    y: content.origin_y - label.value * content.scale * 1px - self.height / 2;
                }
            }

            side_label_left_probe := Text {
                text: root.axis_labels_y.length > 0 ? root.axis_labels_y[0].text : "0";
                color: transparent;
                font-size: ZoomPanInfo.corrected_text_size(
                    root.axis_label_size,
                    content.text_scale
                );
                font-weight: root.axis_label_weight;
                x: floor_rect.x - root.axis_label_offset * content.text_scale - self.width;
                y: floor_rect.y + floor_rect.height / 2 - self.height / 2;
            }

            side_label_right_probe := Text {
                text: root.axis_labels_y.length > 0 ? root.axis_labels_y[0].text : "0";
                color: transparent;
                font-size: ZoomPanInfo.corrected_text_size(
                    root.axis_label_size,
                    content.text_scale
                );
                font-weight: root.axis_label_weight;
                x: floor_rect.x + floor_rect.width + root.axis_label_offset * content.text_scale;
                y: floor_rect.y + floor_rect.height / 2 - self.height / 2;
            }

            top_label_probe := Text {
                text: root.axis_labels_x.length > 0 ? root.axis_labels_x[0].text : "0";
                color: transparent;
                font-size: ZoomPanInfo.corrected_text_size(
                    root.axis_label_size,
                    content.text_scale
                );
                font-weight: root.axis_label_weight;
                x: content.origin_x - self.width / 2;
                y: floor_rect.y
                    - root.axis_label_offset * content.text_scale
                    - root.axis_label_floor_padding * content.text_scale
                    - self.height;
            }

            bottom_label_probe := Text {
                text: root.axis_labels_x.length > 0 ? root.axis_labels_x[0].text : "0";
                color: transparent;
                font-size: ZoomPanInfo.corrected_text_size(
                    root.axis_label_size,
                    content.text_scale
                );
                font-weight: root.axis_label_weight;
                x: content.origin_x - self.width / 2;
                y: floor_rect.y
                    + floor_rect.height
                    + root.axis_label_offset * content.text_scale
                    + root.axis_label_floor_padding * content.text_scale;
            }

            curve_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                z: 3;
                background: transparent;

                for curve in root.curves: Path {
                    width: parent.width;
                    height: parent.height;
                    fill: transparent;
                    stroke: curve.color;
                    stroke-width: root.dancer_border_thickness;
                    viewbox-width: parent.width / 1px;
                    viewbox-height: parent.height / 1px;
                    commands: curve.commands;
                }

                for segment in root.dashed_curve_segments: Path {
                    width: parent.width;
                    height: parent.height;
                    fill: transparent;
                    stroke: segment.color;
                    stroke-width: segment.thickness * 1px;
                    viewbox-width: parent.width / 1px;
                    viewbox-height: parent.height / 1px;
                    commands: segment.commands;
                }
            }

            position_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                z: 4;
                background: transparent;

                for position in root.positions: Rectangle {
                    width: root.dancer_size * content.scale * 1px;
                    height: root.dancer_size * content.scale * 1px;
                    border-radius: self.width / 2;
                    background: position.has_dancer ? position.fill_color : MaterialPalette.surface_variant;
                    border-width: root.dancer_border_thickness;
                    border-color: position.has_dancer ? position.border_color : MaterialPalette.outline_variant;
                    x: content.origin_x + position.x * content.scale * 1px - self.width / 2;
                    y: content.origin_y - position.y * content.scale * 1px - self.height / 2;

                    if position.is_selected : Rectangle {
                        width: parent.width + root.dancer_selection_padding * 2;
                        height: parent.height + root.dancer_selection_padding * 2;
                        border-radius: self.width / 2;
                        border-width: root.dancer_selection_thickness;
                        border-color: root.dancer_selection_color;
                        background: transparent;
                        x: parent.width / 2 - self.width / 2;
                        y: parent.height / 2 - self.height / 2;
                    }

                }
            }

            position_text_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                z: 5;
                background: transparent;

                for position in root.positions: Text {
                    visible: position.has_dancer && position.shortcut != "";
                    text: position.shortcut;
                    color: position.text_color;
                    font-size: ZoomPanInfo.corrected_text_size(
                        root.dancer_size
                            * content.base_scale
                            * 1px
                            * (MaterialTypography.body_medium.font_size / MaterialTypography.title_large.font_size),
                        content.user_scale
                    );
                    font-weight: MaterialTypography.title_medium.font_weight;
                    horizontal-alignment: center;
                    vertical-alignment: center;
                    width: root.dancer_size * content.scale * 1px;
                    height: root.dancer_size * content.scale * 1px;
                    x: content.origin_x + position.x * content.scale * 1px - self.width / 2;
                    y: content.origin_y - position.y * content.scale * 1px - self.height / 2;
                }
            }

            selection_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                z: 7;
                background: transparent;

                for segment in root.selection_segments: Path {
                    width: parent.width;
                    height: parent.height;
                    fill: transparent;
                    stroke: segment.color;
                    stroke-width: segment.thickness * 1px;
                    viewbox-width: parent.width / 1px;
                    viewbox-height: parent.height / 1px;
                    commands: segment.commands;
                }
            }

            legend_panel := FloorLegendPanel {
                x: floor_rect.x + floor_rect.width + FloorLegendEntries.legend_margin * content.text_scale;
                y: floor_rect.y;
                z: 5;
                text_scale: content.text_scale;
            }

            placement_overlay := Rectangle {
                visible: root.show_placement_overlay && root.remaining_positions > 0;
                x: root.placement_padding;
                y: root.placement_padding;
                background: root.placement_background_color;
                border-radius: root.placement_corner_radius;

                Vertical {
                    padding: root.placement_padding;
                    spacing: root.placement_spacing;

                    Text {
                        text: Translations.floor_placement_title;
                        color: root.placement_title_color;
                        font-size: ZoomPanInfo.corrected_text_size(
                            root.placement_title_size,
                            content.user_scale
                        );
                        font-weight: root.placement_title_weight;
                    }

                    Text {
                        text: Translations.floor_placement_hint;
                        color: root.placement_body_color;
                        font-size: ZoomPanInfo.corrected_text_size(
                            root.placement_body_size,
                            content.user_scale
                        );
                        font-weight: root.placement_body_weight;
                    }

                    Text {
                        text: Translations.floor_placement_remaining_prefix + root.remaining_positions;
                        color: root.placement_body_color;
                        font-size: ZoomPanInfo.corrected_text_size(
                            root.placement_body_size,
                            content.user_scale
                        );
                        font-weight: root.placement_body_weight;
                    }
                }
            }

            touch_overlay := TouchArea {
                width: parent.width;
                height: parent.height;
                z: 10;

                pointer-event(event) => {
                    if (event.kind == PointerEventKind.down) {
                        root.pointer_pressed(
                            self.mouse-x / 1px,
                            self.mouse-y / 1px,
                            event.button == PointerEventButton.left,
                            true
                        );
                    }
                    if (event.kind == PointerEventKind.up) {
                        root.pointer_released(
                            self.mouse-x / 1px,
                            self.mouse-y / 1px,
                            event.button == PointerEventButton.left,
                            false
                        );
                    }
                }

                moved => {
                    root.pointer_moved(
                        self.mouse-x / 1px,
                        self.mouse-y / 1px,
                        true,
                        self.pressed
                    );
                }

                scroll-event(event) => {
                    root.pointer_wheel_changed(
                        event.delta-x / 1px,
                        event.delta-y / 1px,
                        self.mouse-x / 1px,
                        self.mouse-y / 1px,
                        event.modifiers.control
                    );
                    return accept;
                }
            }
        }
    }

    header_overlay := FloorHeaderOverlay {
        x: content.floor_x;
        y: content.floor_y - (header_overlay.header_height_px + content.header_floor_spacing_px) * 1px;
        width: content.floor_width;
        height: header_overlay.header_height_px * 1px;
        z: 100;
        scale: content.scale;
    }
}
