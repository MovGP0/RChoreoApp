import { MaterialPalette, Vertical, Horizontal } from "@material";
import { Translations } from "translations.slint";

export struct FloorPosition {
    x: float,
    y: float,
    fill_color: color,
    border_color: color,
    text_color: color,
    shortcut: string,
    is_selected: bool,
    has_dancer: bool,
}

export struct FloorCurve {
    start_x: float,
    start_y: float,
    end_x: float,
    end_y: float,
    control1_x: float,
    control1_y: float,
    control2_x: float,
    control2_y: float,
    has_control1: bool,
    has_control2: bool,
    color: color,
    commands: string,
}

export struct LineSegment {
    start_x: float,
    start_y: float,
    end_x: float,
    end_y: float,
    color: color,
    thickness: float,
    commands: string,
}

export struct AxisLabel {
    value: float,
    text: string,
}

export struct LegendEntry {
    color: color,
    shortcut: string,
    name: string,
    position_text: string,
}

export component FloorCanvasView inherits Rectangle {
    in property <string> choreography_name: "";
    in property <string> scene_name: "";
    in property <int> floor_front: 6;
    in property <int> floor_back: 6;
    in property <int> floor_left: 6;
    in property <int> floor_right: 6;
    in property <bool> show_grid_lines: true;
    in property <color> surface_color: MaterialPalette.surface;
    in property <color> floor_color: MaterialPalette.surface_variant;
    in property <color> grid_color: MaterialPalette.secondary;
    in property <color> floor_border_color: MaterialPalette.primary;
    in property <color> title_color: MaterialPalette.on_surface;
    in property <color> subtitle_color: MaterialPalette.on_surface_variant;
    in property <color> empty_position_fill_color: MaterialPalette.surface_variant;
    in property <color> empty_position_border_color: MaterialPalette.outline_variant;
    in property <length> header_padding: 16px;
    in property <length> header_spacing: 4px;
    in property <length> grid_padding: 46px;
    in property <length> grid_line_thickness: 1px;
    in property <length> border_thickness: 2px;
    in property <length> center_line_thickness: 2px;
    in property <length> center_dot_size: 8px;
    in property <float> pan_x: 0.0;
    in property <float> pan_y: 0.0;
    in property <float> zoom_factor: 1.0;
    in property <float> dancer_size: 1.0;
    in property <length> dancer_text_size: 24px;
    in property <length> dancer_border_thickness: 2px;
    in property <length> dancer_selection_thickness: 3px;
    in property <length> dancer_selection_padding: 4px;
    in property <color> dancer_selection_color: MaterialPalette.secondary;
    in property <[FloorPosition]> positions: [];
    in property <[FloorCurve]> curves: [];
    in property <[LineSegment]> dashed_curve_segments: [];
    in property <[LineSegment]> selection_segments: [];
    in property <[AxisLabel]> axis_labels_x: [];
    in property <[AxisLabel]> axis_labels_y: [];
    in property <length> axis_label_offset: 12px;
    in property <length> axis_label_size: 16px;
    in property <bool> show_axis_labels: false;
    in property <[LegendEntry]> legend_entries: [];
    in property <bool> show_legend: false;
    in property <length> legend_padding: 8px;
    in property <length> legend_row_spacing: 6px;
    in property <length> legend_column_spacing: 10px;
    in property <length> legend_square_size: 10px;
    in property <length> legend_margin: 48px;
    in property <length> legend_panel_width: 240px;
    in property <length> legend_text_size: 14px;
    in property <color> legend_text_color: MaterialPalette.on_surface;
    in property <color> legend_border_color: MaterialPalette.outline_variant;
    in property <image> svg_overlay;
    in property <bool> has_svg_overlay: false;
    in property <bool> show_placement_overlay: false;
    in property <int> remaining_positions: 0;
    in property <length> placement_padding: 12px;
    in property <length> placement_spacing: 4px;
    in property <length> placement_corner_radius: 8px;
    in property <length> placement_title_size: 16px;
    in property <length> placement_body_size: 14px;
    in property <color> placement_title_color: MaterialPalette.on_surface;
    in property <color> placement_body_color: MaterialPalette.on_surface_variant;
    in property <color> placement_background_color: MaterialPalette.surface_variant;
    out property <float> floor_bounds_left: content.floor_x / 1px;
    out property <float> floor_bounds_top: content.floor_y / 1px;
    out property <float> floor_bounds_right: (content.floor_x + content.floor_width) / 1px;
    out property <float> floor_bounds_bottom: (content.floor_y + content.floor_height) / 1px;
    out property <float> canvas_width: root.width / 1px;
    out property <float> canvas_height: root.height / 1px;

    property <float> floor_width_meters: (floor_left + floor_right) * 1.0;
    property <float> floor_height_meters: (floor_front + floor_back) * 1.0;

    callback redraw();
    callback pointer_pressed(x: float, y: float, is_primary: bool, is_in_contact: bool);
    callback pointer_moved(x: float, y: float, is_primary: bool, is_in_contact: bool);
    callback pointer_released(x: float, y: float, is_primary: bool, is_in_contact: bool);
    callback pointer_wheel_changed(delta: float, x: float, y: float);

    changed floor_bounds_left => { root.redraw(); }
    changed floor_bounds_top => { root.redraw(); }
    changed floor_bounds_right => { root.redraw(); }
    changed floor_bounds_bottom => { root.redraw(); }
    changed canvas_width => { root.redraw(); }
    changed canvas_height => { root.redraw(); }
    changed width => { root.redraw(); }
    changed height => { root.redraw(); }

    background: surface_color;

    Vertical {
        spacing: 0px;

        Rectangle {
            width: parent.width;
            height: root.header_padding * 2 + 20px + 14px + root.header_spacing;
            background: root.surface_color;
            Vertical {
                padding: root.header_padding;
                spacing: root.header_spacing;
                Text {
                    text: root.choreography_name;
                    color: root.title_color;
                    font-size: 20px;
                    horizontal-alignment: center;
                }
                Text {
                    text: root.scene_name;
                    color: root.subtitle_color;
                    font-size: 14px;
                    horizontal-alignment: center;
                }
            }
        }

        content := Rectangle {
            vertical-stretch: 1;
            background: root.surface_color;
            changed floor_x => { root.redraw(); }
            changed floor_y => { root.redraw(); }
            changed floor_width => { root.redraw(); }
            changed floor_height => { root.redraw(); }

            property <float> content_width_px: self.width / 1px;
            property <float> content_height_px: self.height / 1px;
            property <float> padding_px: root.grid_padding / 1px;
            property <length> legend_reserved_width: root.show_legend && root.legend_entries.length > 0
                ? root.legend_panel_width + root.legend_margin
                : 0px;
            property <float> layout_width_px: content_width_px > legend_reserved_width / 1px
                ? content_width_px - legend_reserved_width / 1px
                : 0.0;
            property <float> available_width_px: layout_width_px > 2.0 * padding_px
                ? layout_width_px - 2.0 * padding_px
                : 0.0;
            property <float> available_height_px: content_height_px > 2.0 * padding_px
                ? content_height_px - 2.0 * padding_px
                : 0.0;
            property <float> scale_x: root.floor_width_meters > 0.0
                ? available_width_px / root.floor_width_meters
                : 1.0;
            property <float> scale_y: root.floor_height_meters > 0.0
                ? available_height_px / root.floor_height_meters
                : 1.0;
            property <float> base_scale: scale_x < scale_y ? scale_x : scale_y;
            property <float> zoom: root.zoom_factor > 0.0 ? root.zoom_factor : 1.0;
            property <float> scale: base_scale * zoom;
            property <length> floor_width: root.floor_width_meters > 0.0
                ? root.floor_width_meters * scale * 1px
                : 0px;
            property <length> floor_height: root.floor_height_meters > 0.0
                ? root.floor_height_meters * scale * 1px
                : 0px;
            property <length> floor_x: (layout_width_px * 1px - floor_width) / 2 + root.pan_x * 1px;
            property <length> floor_y: (parent.height - floor_height) / 2 + root.pan_y * 1px;
            property <length> center_x: floor_x + floor_width / 2;
            property <length> center_y: floor_y + floor_height / 2;
            property <float> floor_width_px: floor_width / 1px;
            property <float> floor_height_px: floor_height / 1px;

            floor_rect := Rectangle {
                width: content.floor_width;
                height: content.floor_height;
                x: content.floor_x;
                y: content.floor_y;
                z: 0;
                background: root.floor_color;
                border-width: root.border_thickness;
                border-color: root.floor_border_color;
            }

            grid := Rectangle {
                x: floor_rect.x;
                y: floor_rect.y;
                width: floor_rect.width;
                height: floor_rect.height;
                z: 1;
                background: transparent;
                clip: true;
                visible: root.show_grid_lines;

                for i in root.floor_left : Rectangle {
                    width: root.grid_line_thickness;
                    height: parent.height;
                    background: root.grid_color;
                    opacity: 0.5;
                    x: parent.width / 2 - self.width / 2 - (i + 1) * content.scale * 1px;
                    y: 0px;
                }

                for i in root.floor_right : Rectangle {
                    width: root.grid_line_thickness;
                    height: parent.height;
                    background: root.grid_color;
                    opacity: 0.5;
                    x: parent.width / 2 - self.width / 2 + (i + 1) * content.scale * 1px;
                    y: 0px;
                }

                for i in root.floor_front : Rectangle {
                    width: parent.width;
                    height: root.grid_line_thickness;
                    background: root.grid_color;
                    opacity: 0.5;
                    x: 0px;
                    y: parent.height / 2 - self.height / 2 - (i + 1) * content.scale * 1px;
                }

                for i in root.floor_back : Rectangle {
                    width: parent.width;
                    height: root.grid_line_thickness;
                    background: root.grid_color;
                    opacity: 0.5;
                    x: 0px;
                    y: parent.height / 2 - self.height / 2 + (i + 1) * content.scale * 1px;
                }
            }

            center_layer := Rectangle {
                x: floor_rect.x;
                y: floor_rect.y;
                width: floor_rect.width;
                height: floor_rect.height;
                background: transparent;

                Rectangle {
                    width: root.center_line_thickness;
                    height: parent.height;
                    background: root.floor_border_color;
                    x: parent.width / 2 - self.width / 2;
                    y: 0px;
                }

                Rectangle {
                    width: parent.width;
                    height: root.center_line_thickness;
                    background: root.floor_border_color;
                    x: 0px;
                    y: parent.height / 2 - self.height / 2;
                }

                Rectangle {
                    width: root.center_dot_size;
                    height: root.center_dot_size;
                    border-radius: self.width / 2;
                    background: root.floor_border_color;
                    x: parent.width / 2 - self.width / 2;
                    y: parent.height / 2 - self.height / 2;
                }
            }

            axis_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                background: transparent;
                visible: root.show_axis_labels;

                for label in root.axis_labels_x: Text {
                    text: label.text;
                    color: root.subtitle_color;
                    font-size: root.axis_label_size;
                    horizontal-alignment: center;
                    x: content.center_x + label.value * content.scale * 1px - self.width / 2;
                    y: floor_rect.y - root.axis_label_offset;
                }

                for label in root.axis_labels_x: Text {
                    text: label.text;
                    color: root.subtitle_color;
                    font-size: root.axis_label_size;
                    horizontal-alignment: center;
                    x: content.center_x + label.value * content.scale * 1px - self.width / 2;
                    y: floor_rect.y + floor_rect.height + root.axis_label_offset - self.height;
                }

                for label in root.axis_labels_y: Text {
                    text: label.text;
                    color: root.subtitle_color;
                    font-size: root.axis_label_size;
                    horizontal-alignment: right;
                    x: floor_rect.x - root.axis_label_offset - self.width;
                    y: content.center_y - label.value * content.scale * 1px - self.height / 2;
                }

                for label in root.axis_labels_y: Text {
                    text: label.text;
                    color: root.subtitle_color;
                    font-size: root.axis_label_size;
                    horizontal-alignment: left;
                    x: floor_rect.x + floor_rect.width + root.axis_label_offset;
                    y: content.center_y - label.value * content.scale * 1px - self.height / 2;
                }
            }

            curve_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                background: transparent;

                for curve in root.curves: Path {
                    width: parent.width;
                    height: parent.height;
                    fill: transparent;
                    stroke: curve.color;
                    stroke-width: root.dancer_border_thickness;
                    viewbox-width: parent.width / 1px;
                    viewbox-height: parent.height / 1px;
                    commands: curve.commands;
                }

                for segment in root.dashed_curve_segments: Path {
                    width: parent.width;
                    height: parent.height;
                    fill: transparent;
                    stroke: segment.color;
                    stroke-width: segment.thickness * 1px;
                    viewbox-width: parent.width / 1px;
                    viewbox-height: parent.height / 1px;
                    commands: segment.commands;
                }
            }

            position_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                z: 3;
                background: transparent;

                for position in root.positions: Rectangle {
                    width: root.dancer_size * content.scale * 1px;
                    height: root.dancer_size * content.scale * 1px;
                    border-radius: self.width / 2;
                    background: position.has_dancer ? position.fill_color : root.empty_position_fill_color;
                    border-width: root.dancer_border_thickness;
                    border-color: position.has_dancer ? position.border_color : root.empty_position_border_color;
                    x: content.center_x + position.x * content.scale * 1px - self.width / 2;
                    y: content.center_y - position.y * content.scale * 1px - self.height / 2;

                    if position.is_selected : Rectangle {
                        width: parent.width + root.dancer_selection_padding * 2;
                        height: parent.height + root.dancer_selection_padding * 2;
                        border-radius: self.width / 2;
                        border-width: root.dancer_selection_thickness;
                        border-color: root.dancer_selection_color;
                        background: transparent;
                        x: parent.width / 2 - self.width / 2;
                        y: parent.height / 2 - self.height / 2;
                    }

                    if position.has_dancer && position.shortcut != "" : Text {
                        text: position.shortcut;
                        color: position.text_color;
                        font-size: (parent.width < parent.height ? parent.width : parent.height) * 0.45;
                        horizontal-alignment: center;
                        vertical-alignment: center;
                        width: parent.width;
                        height: parent.height;
                    }
                }
            }

            selection_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                background: transparent;

                for segment in root.selection_segments: Path {
                    width: parent.width;
                    height: parent.height;
                    fill: transparent;
                    stroke: segment.color;
                    stroke-width: segment.thickness * 1px;
                    viewbox-width: parent.width / 1px;
                    viewbox-height: parent.height / 1px;
                    commands: segment.commands;
                }
            }

            legend_panel := Rectangle {
                visible: root.show_legend && root.legend_entries.length > 0;
                x: parent.width > root.legend_panel_width + root.grid_padding
                    ? parent.width - root.legend_panel_width - root.grid_padding
                    : 0px;
                y: root.grid_padding;
                z: 5;
                width: root.legend_panel_width;
                height: root.legend_entries.length > 0
                    ? root.legend_padding * 2
                        + (root.legend_entries.length * (root.legend_square_size > root.legend_text_size
                            ? root.legend_square_size
                            : root.legend_text_size))
                        + ((root.legend_entries.length - 1) * root.legend_row_spacing)
                    : 0px;
                background: transparent;
                border-width: 1px;
                border-color: root.legend_border_color;

                Vertical {
                    padding: root.legend_padding;
                    spacing: root.legend_row_spacing;

                    for entry in root.legend_entries: Horizontal {
                        spacing: root.legend_column_spacing;

                        Rectangle {
                            width: root.legend_square_size;
                            height: root.legend_square_size;
                            background: entry.color;
                        }

                        Text {
                            text: entry.shortcut;
                            color: root.legend_text_color;
                            font-size: root.legend_text_size;
                        }

                        Text {
                            text: entry.name;
                            color: root.legend_text_color;
                            font-size: root.legend_text_size;
                        }

                        Text {
                            text: entry.position_text;
                            color: root.legend_text_color;
                            font-size: root.legend_text_size;
                        }
                    }
                }
            }

            placement_overlay := Rectangle {
                visible: root.show_placement_overlay && root.remaining_positions > 0;
                x: root.placement_padding;
                y: root.placement_padding;
                background: root.placement_background_color;
                border-radius: root.placement_corner_radius;

                Vertical {
                    padding: root.placement_padding;
                    spacing: root.placement_spacing;

                    Text {
                        text: Translations.floor_placement_title;
                        color: root.placement_title_color;
                        font-size: root.placement_title_size;
                    }

                    Text {
                        text: Translations.floor_placement_hint;
                        color: root.placement_body_color;
                        font-size: root.placement_body_size;
                    }

                    Text {
                        text: Translations.floor_placement_remaining_prefix + root.remaining_positions;
                        color: root.placement_body_color;
                        font-size: root.placement_body_size;
                    }
                }
            }

            touch_overlay := TouchArea {
                width: parent.width;
                height: parent.height;
                z: 10;

                pointer-event(event) => {
                    if (event.kind == PointerEventKind.down) {
                        root.pointer_pressed(
                            self.mouse-x / 1px,
                            self.mouse-y / 1px,
                            event.button == PointerEventButton.left,
                            true
                        );
                    }
                    if (event.kind == PointerEventKind.up) {
                        root.pointer_released(
                            self.mouse-x / 1px,
                            self.mouse-y / 1px,
                            event.button == PointerEventButton.left,
                            false
                        );
                    }
                }

                moved => {
                    root.pointer_moved(
                        self.mouse-x / 1px,
                        self.mouse-y / 1px,
                        true,
                        self.pressed
                    );
                }

                scroll-event(event) => {
                    root.pointer_wheel_changed(
                        event.delta-y / 1px,
                        self.mouse-x / 1px,
                        self.mouse-y / 1px
                    );
                    return accept;
                }
            }
        }
    }

    svg_overlay_layer := Rectangle {
        x: 0px;
        y: 0px;
        width: root.width;
        height: root.height;
        z: 1;
        background: transparent;
        visible: root.has_svg_overlay;

        Image {
            source: root.svg_overlay;
            width: content.width * content.zoom;
            height: content.height * content.zoom;
            x: content.center_x - self.width / 2;
            y: content.y + content.center_y - self.height / 2;
            image-fit: contain;
        }
    }
}
