import { MaterialPalette, MaterialTypography, Vertical, Horizontal } from "@material";
import { Translations } from "translations.slint";

export struct FloorPosition {
    x: float,
    y: float,
    fill_color: color,
    border_color: color,
    text_color: color,
    shortcut: string,
    is_selected: bool,
    has_dancer: bool,
}

export struct FloorCurve {
    start_x: float,
    start_y: float,
    end_x: float,
    end_y: float,
    control1_x: float,
    control1_y: float,
    control2_x: float,
    control2_y: float,
    has_control1: bool,
    has_control2: bool,
    color: color,
    commands: string,
}

export struct LineSegment {
    start_x: float,
    start_y: float,
    end_x: float,
    end_y: float,
    color: color,
    thickness: float,
    commands: string,
}

export struct AxisLabel {
    value: float,
    text: string,
}

export struct LegendEntry {
    color: color,
    shortcut: string,
    name: string,
    position_text: string,
}

export component FloorCanvasView inherits Rectangle {
    in property <string> choreography_name: "Lorem ipsum dolor sit amet";
    in property <string> scene_name: "Lorem ipsum";
    in property <int> floor_front: 6;
    in property <int> floor_back: 6;
    in property <int> floor_left: 6;
    in property <int> floor_right: 6;
    in property <bool> show_grid_lines: true;
    in property <color> surface_color: MaterialPalette.surface;
    in property <color> floor_color: MaterialPalette.surface_variant;
    in property <color> grid_color: MaterialPalette.secondary;
    in property <color> floor_border_color: MaterialPalette.primary;
    in property <color> title_color: MaterialPalette.on_surface;
    in property <color> subtitle_color: MaterialPalette.on_surface_variant;
    in property <color> empty_position_fill_color: MaterialPalette.surface_variant;
    in property <color> empty_position_border_color: MaterialPalette.outline_variant;
    in property <length> header_padding: 16px;
    in property <length> header_spacing: 4px;
    in property <length> header_floor_spacing: 20px;
    in property <length> grid_padding: 46px;
    in property <length> grid_line_thickness: 1px;
    in property <length> border_thickness: 2px;
    in property <length> center_line_thickness: 2px;
    in property <length> center_dot_size: 8px;
    in property <float> pan_x: 0.0;
    in property <float> pan_y: 0.0;
    in property <float> zoom_factor: 1.0;
    in property <float> dancer_size: 1.0;
    in property <length> dancer_text_size: MaterialTypography.title_large.font_size;
    in property <int> dancer_text_weight: MaterialTypography.title_medium.font_weight;
    in property <length> dancer_border_thickness: 2px;
    in property <length> dancer_selection_thickness: 3px;
    in property <length> dancer_selection_padding: 4px;
    in property <color> dancer_selection_color: MaterialPalette.secondary;
    in property <[FloorPosition]> positions: [];
    in property <[FloorCurve]> curves: [];
    in property <[LineSegment]> dashed_curve_segments: [];
    in property <[LineSegment]> selection_segments: [];
    in property <[AxisLabel]> axis_labels_x: [];
    in property <[AxisLabel]> axis_labels_y: [];
    in property <length> axis_label_offset: 12px;
    in property <length> axis_label_floor_padding: 6px;
    in property <length> axis_label_size: MaterialTypography.label_large.font_size;
    in property <int> axis_label_weight: MaterialTypography.label_large.font_weight;
    in property <bool> show_axis_labels: false;
    in property <[LegendEntry]> legend_entries: [];
    in property <bool> show_legend: false;
    in property <length> legend_padding: 8px;
    in property <length> legend_row_spacing: 6px;
    in property <length> legend_column_spacing: 10px;
    in property <length> legend_square_size: 10px;
    in property <length> legend_margin: 48px;
    in property <length> legend_panel_width: 240px;
    in property <length> legend_text_size: MaterialTypography.body_medium.font_size;
    in property <int> legend_text_weight: MaterialTypography.body_medium.font_weight;
    in property <color> legend_text_color: MaterialPalette.on_surface;
    in property <color> legend_border_color: MaterialPalette.outline_variant;
    in property <image> svg_overlay;
    in property <bool> has_svg_overlay: false;
    in property <bool> show_placement_overlay: false;
    in property <int> remaining_positions: 0;
    in property <length> placement_padding: 12px;
    in property <length> placement_spacing: 4px;
    in property <length> placement_corner_radius: 8px;
    in property <length> placement_title_size: MaterialTypography.title_medium.font_size;
    in property <int> placement_title_weight: MaterialTypography.title_medium.font_weight;
    in property <length> placement_body_size: MaterialTypography.body_medium.font_size;
    in property <int> placement_body_weight: MaterialTypography.body_medium.font_weight;
    in property <length> header_title_size: MaterialTypography.title_large.font_size;
    in property <int> header_title_weight: MaterialTypography.title_large.font_weight;
    in property <length> header_subtitle_size: MaterialTypography.body_medium.font_size;
    in property <int> header_subtitle_weight: MaterialTypography.body_medium.font_weight;
    in property <color> placement_title_color: MaterialPalette.on_surface;
    in property <color> placement_body_color: MaterialPalette.on_surface_variant;
    in property <color> placement_background_color: MaterialPalette.surface_variant;
    out property <float> floor_bounds_left: content.floor_x / 1px;
    out property <float> floor_bounds_top: content.floor_y / 1px;
    out property <float> floor_bounds_right: (content.floor_x + content.floor_width) / 1px;
    out property <float> floor_bounds_bottom: (content.floor_y + content.floor_height) / 1px;
    out property <float> canvas_width: root.width / 1px;
    out property <float> canvas_height: root.height / 1px;

    property <float> floor_width_meters: (floor_left + floor_right) * 1.0;
    property <float> floor_height_meters: (floor_front + floor_back) * 1.0;

    callback redraw();
    callback pointer_pressed(x: float, y: float, is_primary: bool, is_in_contact: bool);
    callback pointer_moved(x: float, y: float, is_primary: bool, is_in_contact: bool);
    callback pointer_released(x: float, y: float, is_primary: bool, is_in_contact: bool);
    callback pointer_wheel_changed(delta: float, x: float, y: float);

    changed floor_bounds_left => { root.redraw(); }
    changed floor_bounds_top => { root.redraw(); }
    changed floor_bounds_right => { root.redraw(); }
    changed floor_bounds_bottom => { root.redraw(); }
    changed canvas_width => { root.redraw(); }
    changed canvas_height => { root.redraw(); }
    changed width => { root.redraw(); }
    changed height => { root.redraw(); }

    background: surface_color;

    Vertical {
        spacing: 0px;

        content := Rectangle {
            vertical-stretch: 1;
            background: root.surface_color;
            changed floor_x => { root.redraw(); }
            changed floor_y => { root.redraw(); }
            changed floor_width => { root.redraw(); }
            changed floor_height => { root.redraw(); }

            property <float> content_width_px: self.width / 1px;
            property <float> content_height_px: self.height / 1px;
            property <float> padding_px: root.grid_padding / 1px;
            property <float> header_height_px: (
                root.header_padding * 2
                + root.header_title_size
                + root.header_spacing
                + root.header_subtitle_size
            ) / 1px * zoom;
            property <float> header_floor_spacing_px: root.header_floor_spacing / 1px * zoom;
            property <length> legend_reserved_width: root.show_legend && root.legend_entries.length > 0
                ? root.legend_panel_width + root.legend_margin
                : 0px;
            property <float> layout_width_px: content_width_px > legend_reserved_width / 1px
                ? content_width_px - legend_reserved_width / 1px
                : 0.0;
            property <float> available_width_px: layout_width_px > 2.0 * padding_px
                ? layout_width_px - 2.0 * padding_px
                : 0.0;
            property <float> available_height_px: content_height_px > header_height_px + header_floor_spacing_px + 2.0 * padding_px
                ? content_height_px - header_height_px - header_floor_spacing_px - 2.0 * padding_px
                : 0.0;
            property <float> scale_x: root.floor_width_meters > 0.0
                ? available_width_px / root.floor_width_meters
                : 1.0;
            property <float> scale_y: root.floor_height_meters > 0.0
                ? available_height_px / root.floor_height_meters
                : 1.0;
            property <float> base_scale: scale_x < scale_y ? scale_x : scale_y;
            property <float> zoom: root.zoom_factor > 0.0 ? root.zoom_factor : 1.0;
            property <float> scale: base_scale * zoom;
            property <float> text_scale: scale > 0.0 ? scale / 48.0 : 1.0;
            property <length> floor_width: root.floor_width_meters > 0.0
                ? root.floor_width_meters * scale * 1px
                : 0px;
            property <length> floor_height: root.floor_height_meters > 0.0
                ? root.floor_height_meters * scale * 1px
                : 0px;
            property <length> floor_x: (layout_width_px * 1px - floor_width) / 2 + root.pan_x * 1px;
            property <length> floor_y: (header_height_px + header_floor_spacing_px) * 1px
                + (parent.height - (header_height_px + header_floor_spacing_px) * 1px - floor_height) / 2
                + root.pan_y * 1px;
            property <length> center_x: floor_x + floor_width / 2;
            property <length> center_y: floor_y + floor_height / 2;
            property <length> origin_x: floor_x + root.floor_left * content.scale * 1px;
            property <length> origin_y: floor_y + root.floor_front * content.scale * 1px;
            property <float> floor_width_px: floor_width / 1px;
            property <float> floor_height_px: floor_height / 1px;

            floor_rect := Rectangle {
                width: content.floor_width;
                height: content.floor_height;
                x: content.floor_x;
                y: content.floor_y;
                z: 0;
                background: root.floor_color;
                border-width: root.border_thickness;
                border-color: root.floor_border_color;
            }

            grid := Rectangle {
                x: floor_rect.x;
                y: floor_rect.y;
                width: floor_rect.width;
                height: floor_rect.height;
                z: 1;
                background: transparent;
                clip: true;
                visible: root.show_grid_lines;

                for i in root.floor_left : Rectangle {
                    width: root.grid_line_thickness;
                    height: parent.height;
                    background: root.grid_color;
                    opacity: 0.5;
                    x: content.origin_x - floor_rect.x - self.width / 2 - (i + 1) * content.scale * 1px;
                    y: 0px;
                }

                for i in root.floor_right : Rectangle {
                    width: root.grid_line_thickness;
                    height: parent.height;
                    background: root.grid_color;
                    opacity: 0.5;
                    x: content.origin_x - floor_rect.x - self.width / 2 + (i + 1) * content.scale * 1px;
                    y: 0px;
                }

                for i in root.floor_front : Rectangle {
                    width: parent.width;
                    height: root.grid_line_thickness;
                    background: root.grid_color;
                    opacity: 0.5;
                    x: 0px;
                    y: content.origin_y - floor_rect.y - self.height / 2 - (i + 1) * content.scale * 1px;
                }

                for i in root.floor_back : Rectangle {
                    width: parent.width;
                    height: root.grid_line_thickness;
                    background: root.grid_color;
                    opacity: 0.5;
                    x: 0px;
                    y: content.origin_y - floor_rect.y - self.height / 2 + (i + 1) * content.scale * 1px;
                }
            }

            center_layer := Rectangle {
                x: floor_rect.x;
                y: floor_rect.y;
                width: floor_rect.width;
                height: floor_rect.height;
                z: 1;
                background: transparent;

                Rectangle {
                    width: root.center_line_thickness;
                    height: parent.height;
                    background: root.floor_border_color;
                    x: content.origin_x - floor_rect.x - self.width / 2;
                    y: 0px;
                }

                Rectangle {
                    width: parent.width;
                    height: root.center_line_thickness;
                    background: root.floor_border_color;
                    x: 0px;
                    y: content.origin_y - floor_rect.y - self.height / 2;
                }

                Rectangle {
                    width: root.center_dot_size;
                    height: root.center_dot_size;
                    border-radius: self.width / 2;
                    background: root.floor_border_color;
                    x: content.origin_x - floor_rect.x - self.width / 2;
                    y: content.origin_y - floor_rect.y - self.height / 2;
                }
            }

            svg_overlay_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                z: 2;
                background: transparent;
                visible: root.has_svg_overlay;

                Image {
                    source: root.svg_overlay;
                    width: content.layout_width_px * 1px * content.zoom;
                    height: content.content_height_px * 1px * content.zoom;
                    x: content.origin_x - self.width / 2;
                    y: content.origin_y - self.height / 2;
                    image-fit: contain;
                }
            }

            axis_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                z: 6;
                background: transparent;
                visible: root.show_axis_labels;

                for label in root.axis_labels_x: Text {
                    text: label.text;
                    color: root.subtitle_color;
                    font-size: root.axis_label_size * content.text_scale;
                    font-weight: root.axis_label_weight;
                    horizontal-alignment: center;
                    x: content.origin_x + label.value * content.scale * 1px - self.width / 2;
                    y: floor_rect.y - root.axis_label_offset - root.axis_label_floor_padding - self.height;
                }

                for label in root.axis_labels_x: Text {
                    text: label.text;
                    color: root.subtitle_color;
                    font-size: root.axis_label_size * content.text_scale;
                    font-weight: root.axis_label_weight;
                    horizontal-alignment: center;
                    x: content.origin_x + label.value * content.scale * 1px - self.width / 2;
                    y: floor_rect.y + floor_rect.height + root.axis_label_offset + root.axis_label_floor_padding;
                }

                for label in root.axis_labels_y: Text {
                    text: label.text;
                    color: root.subtitle_color;
                    font-size: root.axis_label_size * content.text_scale;
                    font-weight: root.axis_label_weight;
                    horizontal-alignment: right;
                    x: floor_rect.x - root.axis_label_offset - self.width;
                    y: content.origin_y - label.value * content.scale * 1px - self.height / 2;
                }

                for label in root.axis_labels_y: Text {
                    text: label.text;
                    color: root.subtitle_color;
                    font-size: root.axis_label_size * content.text_scale;
                    font-weight: root.axis_label_weight;
                    horizontal-alignment: left;
                    x: floor_rect.x + floor_rect.width + root.axis_label_offset;
                    y: content.origin_y - label.value * content.scale * 1px - self.height / 2;
                }
            }

            curve_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                z: 3;
                background: transparent;

                for curve in root.curves: Path {
                    width: parent.width;
                    height: parent.height;
                    fill: transparent;
                    stroke: curve.color;
                    stroke-width: root.dancer_border_thickness;
                    viewbox-width: parent.width / 1px;
                    viewbox-height: parent.height / 1px;
                    commands: curve.commands;
                }

                for segment in root.dashed_curve_segments: Path {
                    width: parent.width;
                    height: parent.height;
                    fill: transparent;
                    stroke: segment.color;
                    stroke-width: segment.thickness * 1px;
                    viewbox-width: parent.width / 1px;
                    viewbox-height: parent.height / 1px;
                    commands: segment.commands;
                }
            }

            position_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                z: 4;
                background: transparent;

                for position in root.positions: Rectangle {
                    width: root.dancer_size * content.scale * 1px;
                    height: root.dancer_size * content.scale * 1px;
                    border-radius: self.width / 2;
                    background: position.has_dancer ? position.fill_color : root.empty_position_fill_color;
                    border-width: root.dancer_border_thickness;
                    border-color: position.has_dancer ? position.border_color : root.empty_position_border_color;
                    x: content.origin_x + position.x * content.scale * 1px - self.width / 2;
                    y: content.origin_y - position.y * content.scale * 1px - self.height / 2;

                    if position.is_selected : Rectangle {
                        width: parent.width + root.dancer_selection_padding * 2;
                        height: parent.height + root.dancer_selection_padding * 2;
                        border-radius: self.width / 2;
                        border-width: root.dancer_selection_thickness;
                        border-color: root.dancer_selection_color;
                        background: transparent;
                        x: parent.width / 2 - self.width / 2;
                        y: parent.height / 2 - self.height / 2;
                    }

                }
            }

            position_text_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                z: 5;
                background: transparent;

                for position in root.positions: Text {
                    visible: position.has_dancer && position.shortcut != "";
                    text: position.shortcut;
                    color: position.text_color;
                    font-size: root.dancer_size
                        * content.scale
                        * 1px
                        * (MaterialTypography.body_medium.font_size / MaterialTypography.title_large.font_size);
                    font-weight: root.dancer_text_weight;
                    horizontal-alignment: center;
                    vertical-alignment: center;
                    width: root.dancer_size * content.scale * 1px;
                    height: root.dancer_size * content.scale * 1px;
                    x: content.origin_x + position.x * content.scale * 1px - self.width / 2;
                    y: content.origin_y - position.y * content.scale * 1px - self.height / 2;
                }
            }

            selection_layer := Rectangle {
                x: 0px;
                y: 0px;
                width: parent.width;
                height: parent.height;
                z: 7;
                background: transparent;

                for segment in root.selection_segments: Path {
                    width: parent.width;
                    height: parent.height;
                    fill: transparent;
                    stroke: segment.color;
                    stroke-width: segment.thickness * 1px;
                    viewbox-width: parent.width / 1px;
                    viewbox-height: parent.height / 1px;
                    commands: segment.commands;
                }
            }

            legend_panel := Rectangle {
                visible: root.show_legend && root.legend_entries.length > 0;
                x: floor_rect.x + floor_rect.width + root.legend_margin * content.zoom;
                y: floor_rect.y;
                z: 5;
                width: root.legend_panel_width * content.zoom;
                height: legend_content.preferred-height + root.legend_padding * 2 * content.zoom;
                background: transparent;
                border-width: 1px;
                border-color: root.legend_border_color;

                legend_content := Vertical {
                    spacing: root.legend_row_spacing * content.zoom;
                    x: root.legend_padding * content.zoom;
                    y: root.legend_padding * content.zoom;
                    width: parent.width - root.legend_padding * 2 * content.zoom;

                    for entry in root.legend_entries: Horizontal {
                        spacing: root.legend_column_spacing * content.zoom;

                        Rectangle {
                            width: root.legend_square_size * content.zoom;
                            height: root.legend_square_size * content.zoom;
                            background: entry.color;
                        }

                        Text {
                            text: entry.shortcut;
                            color: root.legend_text_color;
                            font-size: root.legend_text_size * content.text_scale;
                            font-weight: root.legend_text_weight;
                        }

                        Text {
                            text: entry.name;
                            color: root.legend_text_color;
                            font-size: root.legend_text_size * content.text_scale;
                            font-weight: root.legend_text_weight;
                        }

                        Text {
                            text: entry.position_text;
                            color: root.legend_text_color;
                            font-size: root.legend_text_size * content.text_scale;
                            font-weight: root.legend_text_weight;
                        }
                    }
                }
            }

            placement_overlay := Rectangle {
                visible: root.show_placement_overlay && root.remaining_positions > 0;
                x: root.placement_padding;
                y: root.placement_padding;
                background: root.placement_background_color;
                border-radius: root.placement_corner_radius;

                Vertical {
                    padding: root.placement_padding;
                    spacing: root.placement_spacing;

                    Text {
                        text: Translations.floor_placement_title;
                        color: root.placement_title_color;
                        font-size: root.placement_title_size;
                        font-weight: root.placement_title_weight;
                    }

                    Text {
                        text: Translations.floor_placement_hint;
                        color: root.placement_body_color;
                        font-size: root.placement_body_size;
                        font-weight: root.placement_body_weight;
                    }

                    Text {
                        text: Translations.floor_placement_remaining_prefix + root.remaining_positions;
                        color: root.placement_body_color;
                        font-size: root.placement_body_size;
                        font-weight: root.placement_body_weight;
                    }
                }
            }

            touch_overlay := TouchArea {
                width: parent.width;
                height: parent.height;
                z: 10;

                pointer-event(event) => {
                    if (event.kind == PointerEventKind.down) {
                        root.pointer_pressed(
                            self.mouse-x / 1px,
                            self.mouse-y / 1px,
                            event.button == PointerEventButton.left,
                            true
                        );
                    }
                    if (event.kind == PointerEventKind.up) {
                        root.pointer_released(
                            self.mouse-x / 1px,
                            self.mouse-y / 1px,
                            event.button == PointerEventButton.left,
                            false
                        );
                    }
                }

                moved => {
                    root.pointer_moved(
                        self.mouse-x / 1px,
                        self.mouse-y / 1px,
                        true,
                        self.pressed
                    );
                }

                scroll-event(event) => {
                    root.pointer_wheel_changed(
                        event.delta-y / 1px,
                        self.mouse-x / 1px,
                        self.mouse-y / 1px
                    );
                    return accept;
                }
            }
        }
    }

    header_overlay := Rectangle {
        x: 0px;
        y: 0px;
        width: root.width;
        height: root.height;
        z: 100;
        background: transparent;

        header_box := Rectangle {
            x: content.floor_x;
            y: content.floor_y - (content.header_height_px + content.header_floor_spacing_px) * 1px;
            width: content.floor_width;
            height: content.header_height_px * 1px;
            background: transparent;

            Text {
                text: root.choreography_name;
                color: root.title_color;
                font-size: root.header_title_size * content.text_scale;
                font-weight: root.header_title_weight;
                horizontal-alignment: center;
                vertical-alignment: center;
                width: parent.width;
                height: root.header_title_size * content.text_scale;
                y: root.header_padding * content.text_scale;
            }

            Text {
                text: root.scene_name;
                color: root.subtitle_color;
                font-size: root.header_subtitle_size * content.text_scale;
                font-weight: root.header_subtitle_weight;
                horizontal-alignment: center;
                vertical-alignment: center;
                width: parent.width;
                height: root.header_subtitle_size * content.text_scale;
                y: root.header_padding * content.text_scale
                    + root.header_title_size * content.text_scale
                    + root.header_spacing * content.text_scale;
            }
        }
    }

}
